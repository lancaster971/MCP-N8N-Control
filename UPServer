#!/bin/bash

# UPServer - Enterprise Service Manager per PilotPro Control Center
# Rileva stato componenti, avvia solo quello che serve, gestisce servizi separati

set -e

# Colori Linux-style
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# Configuration
BACKEND_PORT=3001
FRONTEND_PORT=5173
DATABASE_NAME="n8n_mcp"
DB_USER="tizianoannicchiarico"

# PID files per service management
BACKEND_PID_FILE="/tmp/pilotpro_backend.pid"
FRONTEND_PID_FILE="/tmp/pilotpro_frontend.pid"
SCHEDULER_STATUS_FILE="/tmp/pilotpro_scheduler_status"

# Environment variables per backend
export WEBHOOK_SECRET=pilotpro-webhook-2025-secure
export DB_USER=$DB_USER
export N8N_API_URL=https://flow.agentix-io.com/rest
export N8N_API_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkMjAxMWVhMy0xNzU3LTQ4M2ItODA3Yc0xYTFjYWRmZTc2MTgiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzU1MTE4OTk1fQ.fCnTxxEgWFYzrG4nKvbA4mZ5VMhd-pc9uxBgAVmOgAI
export MULTI_TENANT_MODE=false
export DEFAULT_TENANT_ID=client_simulation_a
export DEBUG=true
export PORT=$BACKEND_PORT

# Argument handling
ACTION=${1:-"start"} # start, stop, restart, status

# Service management functions
print_status() {
    local service="$1"
    local status="$2"
    local message="$3"
    
    printf "%-20s" "$service"
    if [ "$status" = "OK" ]; then
        echo -e "${GREEN}[  OK  ]${NC} $message"
    elif [ "$status" = "FAIL" ]; then
        echo -e "${RED}[FAILED]${NC} $message"
    elif [ "$status" = "WARN" ]; then
        echo -e "${YELLOW}[ WARN ]${NC} $message"
    elif [ "$status" = "SKIP" ]; then
        echo -e "${CYAN}[ SKIP ]${NC} $message"
    else
        echo -e "${CYAN}[ INFO ]${NC} $message"
    fi
}

check_port() {
    local port="$1"
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

check_process_by_pid() {
    local pid_file="$1"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            echo "$pid"
            return 0
        else
            rm -f "$pid_file"
            return 1
        fi
    fi
    return 1
}

check_database() {
    if /opt/homebrew/opt/postgresql@16/bin/psql -h localhost -U $DB_USER -d $DATABASE_NAME -c "SELECT 1;" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

check_backend_health() {
    if curl -s http://localhost:$BACKEND_PORT/health >/dev/null 2>&1; then
        local health_status=$(curl -s http://localhost:$BACKEND_PORT/health | jq -r '.status // "unknown"' 2>/dev/null)
        if [ "$health_status" = "healthy" ]; then
            return 0
        fi
    fi
    return 1
}

check_frontend_health() {
    if curl -s http://localhost:$FRONTEND_PORT >/dev/null 2>&1; then
        if curl -s http://localhost:$FRONTEND_PORT | grep -q "PilotPro" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

get_service_status() {
    local service="$1"
    
    case $service in
        "database")
            if check_database; then
                echo "running"
            else
                echo "stopped"
            fi
            ;;
        "backend")
            local backend_pid=$(check_process_by_pid "$BACKEND_PID_FILE" 2>/dev/null || echo "")
            if [ -n "$backend_pid" ] && check_port $BACKEND_PORT && check_backend_health; then
                echo "running:$backend_pid"
            elif check_port $BACKEND_PORT; then
                echo "port_occupied"
            else
                echo "stopped"
            fi
            ;;
        "frontend")
            local frontend_pid=$(check_process_by_pid "$FRONTEND_PID_FILE" 2>/dev/null || echo "")
            if [ -n "$frontend_pid" ] && check_port $FRONTEND_PORT && check_frontend_health; then
                echo "running:$frontend_pid"
            elif check_port $FRONTEND_PORT; then
                echo "port_occupied"
            else
                echo "stopped"
            fi
            ;;
    esac
}

start_backend() {
    local backend_status=$(get_service_status "backend")
    
    case $backend_status in
        running:*)
            local pid=$(echo $backend_status | cut -d: -f2)
            print_status "Backend" "SKIP" "Already running (PID: $pid)"
            return 0
            ;;
        port_occupied)
            print_status "Backend" "WARN" "Port $BACKEND_PORT occupied by unknown process"
            echo -e "${YELLOW}Attempting to kill existing process...${NC}"
            pkill -f "express-server.js" 2>/dev/null || true
            sleep 3
            ;;
        stopped)
            print_status "Backend" "INFO" "Starting Express API server..."
            ;;
    esac
    
    # Check build
    if [ ! -f "build/server/express-server.js" ]; then
        print_status "Backend" "WARN" "Build not found, building..."
        if npm run build >/dev/null 2>&1; then
            print_status "Backend" "OK" "Build completed"
        else
            print_status "Backend" "FAIL" "Build failed"
            return 1
        fi
    fi
    
    # Start backend
    nohup node build/server/express-server.js > /tmp/pilotpro_backend.log 2>&1 &
    local backend_pid=$!
    echo "$backend_pid" > "$BACKEND_PID_FILE"
    
    # Wait for startup
    local count=0
    while [ $count -lt 15 ]; do
        if check_port $BACKEND_PORT && check_backend_health; then
            print_status "Backend" "OK" "API server running (PID: $backend_pid)"
            return 0
        fi
        sleep 1
        count=$((count + 1))
    done
    
    print_status "Backend" "FAIL" "Failed to start within 15s"
    return 1
}

start_frontend() {
    local frontend_status=$(get_service_status "frontend")
    
    case $frontend_status in
        running:*)
            local pid=$(echo $frontend_status | cut -d: -f2)
            print_status "Frontend" "SKIP" "Already running (PID: $pid)"
            return 0
            ;;
        port_occupied)
            print_status "Frontend" "WARN" "Port $FRONTEND_PORT occupied by unknown process"
            echo -e "${YELLOW}Attempting to kill existing frontend processes...${NC}"
            pkill -f "npm run dev" 2>/dev/null || true
            pkill -f "vite" 2>/dev/null || true
            sleep 3
            ;;
        stopped)
            print_status "Frontend" "INFO" "Starting React development server..."
            ;;
    esac
    
    # Check frontend directory
    if [ ! -d "frontend" ]; then
        print_status "Frontend" "FAIL" "Frontend directory not found"
        return 1
    fi
    
    # Start frontend
    cd frontend
    nohup npm run dev > /tmp/pilotpro_frontend.log 2>&1 &
    local frontend_pid=$!
    echo "$frontend_pid" > "$FRONTEND_PID_FILE"
    cd ..
    
    # Wait for startup
    local count=0
    while [ $count -lt 20 ]; do
        if check_port $FRONTEND_PORT && check_frontend_health; then
            print_status "Frontend" "OK" "React server running (PID: $frontend_pid)"
            return 0
        fi
        sleep 1
        count=$((count + 1))
    done
    
    print_status "Frontend" "FAIL" "Failed to start within 20s"
    return 1
}

start_scheduler() {
    print_status "Scheduler" "INFO" "Checking scheduler status..."
    
    # Get auth token
    local login_response=$(curl -s -X POST http://localhost:$BACKEND_PORT/auth/login \
        -H "Content-Type: application/json" \
        -d '{"email":"admin@pilotpro.local","password":"admin123"}' 2>/dev/null)
    
    if ! echo "$login_response" | jq -e '.token' >/dev/null 2>&1; then
        print_status "Scheduler" "FAIL" "Cannot authenticate for scheduler management"
        return 1
    fi
    
    local auth_token=$(echo "$login_response" | jq -r '.token')
    
    # Check current status
    local scheduler_status=$(curl -s -H "Authorization: Bearer $auth_token" \
        http://localhost:$BACKEND_PORT/api/scheduler/status 2>/dev/null)
    
    if echo "$scheduler_status" | jq -e '.scheduler.isRunning' >/dev/null 2>&1; then
        local is_running=$(echo "$scheduler_status" | jq -r '.scheduler.isRunning')
        if [ "$is_running" = "true" ]; then
            print_status "Scheduler" "SKIP" "Already running (auto-sync every 5min)"
            echo "true" > "$SCHEDULER_STATUS_FILE"
            return 0
        fi
    fi
    
    # Start scheduler
    local start_response=$(curl -s -X POST -H "Authorization: Bearer $auth_token" \
        http://localhost:$BACKEND_PORT/api/scheduler/start 2>/dev/null)
    
    if echo "$start_response" | jq -e '.status.isRunning' >/dev/null 2>&1; then
        local is_running=$(echo "$start_response" | jq -r '.status.isRunning')
        if [ "$is_running" = "true" ]; then
            print_status "Scheduler" "OK" "Auto-sync enabled (5min intervals)"
            echo "true" > "$SCHEDULER_STATUS_FILE"
            return 0
        fi
    fi
    
    print_status "Scheduler" "FAIL" "Failed to start scheduler"
    return 1
}

stop_service() {
    local service="$1"
    
    case $service in
        "backend")
            if [ -f "$BACKEND_PID_FILE" ]; then
                local pid=$(cat "$BACKEND_PID_FILE")
                if kill -0 "$pid" 2>/dev/null; then
                    print_status "Backend" "INFO" "Stopping PID $pid"
                    kill "$pid"
                    sleep 2
                    if kill -0 "$pid" 2>/dev/null; then
                        kill -9 "$pid" 2>/dev/null || true
                    fi
                fi
                rm -f "$BACKEND_PID_FILE"
            fi
            pkill -f "express-server.js" 2>/dev/null || true
            print_status "Backend" "OK" "Stopped"
            ;;
        "frontend")
            if [ -f "$FRONTEND_PID_FILE" ]; then
                local pid=$(cat "$FRONTEND_PID_FILE")
                if kill -0 "$pid" 2>/dev/null; then
                    print_status "Frontend" "INFO" "Stopping PID $pid"
                    kill "$pid"
                    sleep 2
                    if kill -0 "$pid" 2>/dev/null; then
                        kill -9 "$pid" 2>/dev/null || true
                    fi
                fi
                rm -f "$FRONTEND_PID_FILE"
            fi
            pkill -f "npm run dev" 2>/dev/null || true
            pkill -f "vite" 2>/dev/null || true
            print_status "Frontend" "OK" "Stopped"
            ;;
        "all")
            stop_service "backend"
            stop_service "frontend"
            rm -f "$SCHEDULER_STATUS_FILE"
            ;;
    esac
}

check_system_status() {
    echo -e "${BOLD}${BLUE}🔍 PilotPro System Status Check${NC}"
    echo "================================"
    
    # Database check
    local db_status=$(get_service_status "database")
    if [ "$db_status" = "running" ]; then
        local tenant_count=$(/opt/homebrew/opt/postgresql@16/bin/psql -h localhost -U $DB_USER -d $DATABASE_NAME -t -c "SELECT COUNT(*) FROM tenants;" 2>/dev/null | xargs || echo "0")
        print_status "Database" "OK" "PostgreSQL connected ($tenant_count tenant(s))"
    else
        print_status "Database" "FAIL" "PostgreSQL not accessible"
        return 1
    fi
    
    # Backend check
    local backend_status=$(get_service_status "backend")
    case $backend_status in
        running:*)
            local pid=$(echo $backend_status | cut -d: -f2)
            print_status "Backend" "OK" "API server running (PID: $pid, port: $BACKEND_PORT)"
            ;;
        port_occupied)
            print_status "Backend" "WARN" "Port $BACKEND_PORT occupied by unknown process"
            ;;
        stopped)
            print_status "Backend" "FAIL" "API server not running"
            ;;
    esac
    
    # Frontend check  
    local frontend_status=$(get_service_status "frontend")
    case $frontend_status in
        running:*)
            local pid=$(echo $frontend_status | cut -d: -f2)
            print_status "Frontend" "OK" "React server running (PID: $pid, port: $FRONTEND_PORT)"
            ;;
        port_occupied)
            print_status "Frontend" "WARN" "Port $FRONTEND_PORT occupied by unknown process"
            ;;
        stopped)
            print_status "Frontend" "FAIL" "React server not running"
            ;;
    esac
    
    # Scheduler check (only if backend is running)
    if [ "$backend_status" != "stopped" ]; then
        if [ -f "$SCHEDULER_STATUS_FILE" ] && [ "$(cat $SCHEDULER_STATUS_FILE 2>/dev/null)" = "true" ]; then
            print_status "Scheduler" "OK" "Auto-sync active (every 5min)"
        else
            print_status "Scheduler" "WARN" "Status unknown or inactive"
        fi
    else
        print_status "Scheduler" "FAIL" "Cannot check - backend not running"
    fi
    
    echo ""
}

run_health_tests() {
    echo -e "${BOLD}${BLUE}🏥 System Health Tests${NC}"
    echo "======================"
    
    # API Integration test
    if check_backend_health; then
        local login_response=$(curl -s -X POST http://localhost:$BACKEND_PORT/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@pilotpro.local","password":"admin123"}' 2>/dev/null)
        
        if echo "$login_response" | jq -e '.token' >/dev/null 2>&1; then
            local auth_token=$(echo "$login_response" | jq -r '.token')
            
            # Test workflows API
            local workflows_test=$(curl -s -H "Authorization: Bearer $auth_token" \
                http://localhost:$BACKEND_PORT/api/tenant/client_simulation_a/workflows 2>/dev/null)
            
            if echo "$workflows_test" | jq -e '.total' >/dev/null 2>&1; then
                local total_wf=$(echo "$workflows_test" | jq -r '.total')
                print_status "API Integration" "OK" "$total_wf workflows accessible"
            else
                print_status "API Integration" "WARN" "Workflows API not responding correctly"
            fi
            
            # Test executions API  
            local executions_test=$(curl -s -H "Authorization: Bearer $auth_token" \
                http://localhost:$BACKEND_PORT/api/tenant/client_simulation_a/executions 2>/dev/null)
            
            if echo "$executions_test" | jq -e '.pagination.total' >/dev/null 2>&1; then
                local total_exec=$(echo "$executions_test" | jq -r '.pagination.total')
                print_status "Data Sync" "OK" "$total_exec executions in database"
            else
                print_status "Data Sync" "WARN" "Executions API not responding correctly"
            fi
            
            # Last execution check
            local last_exec=$(/opt/homebrew/opt/postgresql@16/bin/psql -h localhost -U $DB_USER -d $DATABASE_NAME -t -c "SELECT MAX(started_at) FROM tenant_executions WHERE tenant_id = 'client_simulation_a';" 2>/dev/null | xargs)
            if [ -n "$last_exec" ]; then
                print_status "Data Freshness" "OK" "Last execution: $last_exec"
            else
                print_status "Data Freshness" "WARN" "No execution data found"
            fi
        else
            print_status "Authentication" "FAIL" "Cannot login to API"
        fi
    else
        print_status "Backend Health" "FAIL" "Backend not healthy"
    fi
    
    echo ""
}

start_system() {
    echo -e "${BOLD}${BLUE}🚀 PilotPro Control Center - Service Manager${NC}"
    echo "============================================"
    echo -e "${CYAN}Intelligent startup: only starts what's needed${NC}"
    echo ""
    
    # 1. Database check (prerequisite)
    print_status "Database" "INFO" "Checking PostgreSQL connection..."
    if ! check_database; then
        print_status "Database" "FAIL" "PostgreSQL not accessible - start PostgreSQL first"
        exit 1
    fi
    print_status "Database" "OK" "PostgreSQL connected ($DATABASE_NAME)"
    
    # 2. Backend service management
    if ! start_backend; then
        echo -e "${RED}❌ Failed to start backend service${NC}"
        exit 1
    fi
    
    # 3. Frontend service management  
    if ! start_frontend; then
        echo -e "${RED}❌ Failed to start frontend service${NC}"
        exit 1
    fi
    
    # 4. Scheduler management
    sleep 2 # Allow backend to fully start
    start_scheduler
    
    # 5. Health tests
    echo ""
    run_health_tests
    
    # 6. System ready
    echo -e "${BOLD}${BLUE}📊 System Status Summary${NC}"
    echo "========================"
    echo -e "${GREEN}✅ Backend:${NC}   http://localhost:$BACKEND_PORT"
    echo -e "${GREEN}✅ Frontend:${NC}  http://localhost:$FRONTEND_PORT"
    echo -e "${GREEN}✅ Database:${NC}  PostgreSQL ($DATABASE_NAME)"
    echo -e "${GREEN}✅ Scheduler:${NC} Auto-sync with n8n every 5 minutes"
    
    echo ""
    echo -e "${BOLD}${YELLOW}🎯 Quick Access:${NC}"
    echo "  • Dashboard:     http://localhost:$FRONTEND_PORT"
    echo "  • API Docs:      http://localhost:$BACKEND_PORT/api-docs"
    echo "  • Health Check:  http://localhost:$BACKEND_PORT/health"
    echo "  • Settings:      http://localhost:$FRONTEND_PORT/settings"
    echo "  • Admin Login:   admin@pilotpro.local / admin123"
    
    echo ""
    echo -e "${BOLD}${CYAN}📋 Service Management:${NC}"
    echo "  • Status:        ./UPServer status"
    echo "  • Stop:          ./UPServer stop"
    echo "  • Restart:       ./UPServer restart"
    echo "  • Backend only:  ./UPServer backend"
    echo "  • Frontend only: ./UPServer frontend"
    
    echo ""
    echo -e "${BOLD}${GREEN}🚀 SYSTEM READY FOR USE!${NC}"
}

stop_system() {
    echo -e "${BOLD}${BLUE}🛑 PilotPro Control Center - Shutdown${NC}"
    echo "====================================="
    
    stop_service "all"
    
    echo -e "${GREEN}✅ All services stopped${NC}"
}

restart_system() {
    echo -e "${BOLD}${BLUE}🔄 PilotPro Control Center - Restart${NC}"
    echo "===================================="
    
    stop_service "all"
    sleep 3
    start_system
}

# Main execution logic
case $ACTION in
    "start")
        start_system
        ;;
    "stop")
        stop_system
        ;;
    "restart")
        restart_system
        ;;
    "status")
        check_system_status
        run_health_tests
        ;;
    "backend")
        echo -e "${BOLD}${BLUE}🔧 Backend Service Manager${NC}"
        echo "=========================="
        start_backend && echo -e "${GREEN}✅ Backend service ready${NC}"
        ;;
    "frontend")
        echo -e "${BOLD}${BLUE}🎨 Frontend Service Manager${NC}"
        echo "=========================="
        start_frontend && echo -e "${GREEN}✅ Frontend service ready${NC}"
        ;;
    *)
        echo -e "${BOLD}${BLUE}🚀 PilotPro Control Center - Service Manager${NC}"
        echo "============================================"
        echo ""
        echo -e "${YELLOW}Usage:${NC}"
        echo "  ./UPServer [start|stop|restart|status|backend|frontend]"
        echo ""
        echo -e "${YELLOW}Commands:${NC}"
        echo "  start     - Start all services (default)"
        echo "  stop      - Stop all services"
        echo "  restart   - Restart all services"
        echo "  status    - Check system status"
        echo "  backend   - Start/check backend only"
        echo "  frontend  - Start/check frontend only"
        echo ""
        echo -e "${YELLOW}Examples:${NC}"
        echo "  ./UPServer              # Start everything"
        echo "  ./UPServer status       # Check what's running"
        echo "  ./UPServer backend      # Start only backend"
        echo "  ./UPServer restart      # Restart all services"
        ;;
esac